# core

This contains the core of Esom: the audio generation & processing.

Audio is obtained from a source, see [`source.h`](source.h). The source, given
some parameters configured with the `sourceSetParam` function, will give us how
large of a buffer it needs via `sourceBufferSize`. After allocating the buffer,
we have the source place samples in it via `sourceFillBuffer`. The buffer will
contain appropriately synthesized audio. The source can be reconfigured and used
multiple times, which is more optimal than making new sources over and over.
Once a source is no longer, needed `sourceDestroy` must be called.

Sources are rather simple: they consist of a pointer to some specific data and
function pointers implementing the specific kind of audio source. For example,
the data layout and the functions used by the `sine` source are different to the
ones used by the `noise` source. Implementing a new source is as easy as
implementing the necessary functions and adding a case to the `mkSource`
function to allow the source to be created from its name.

The functions a source must implement are:
* `SetParam`: configure the source. The parameters should
  have sensible defaults as we can never guarantee this function will ever be
  called.
* `BufferSize`: calculate how many samples the source will output. Note
  that the buffer that is provided to the source may be larger or lower than the
  value returned from this function under some circumstances.
* `FillBuffer`: write audio data to the provided `Buffer`. You should
  never assume anything about the size of the buffer and always use the length
  of the buffer as your limit rather than whatever you calculated in
  `BufferSize`.
* `Destroy`: free any memory allocated for the source. This is necessary
  because sources must store their data with a single pointer - likely to
  heap-allocated memory.

Once some audio is generated by a source, we can then hand it over to some
processors. A processor is simple: audio goes in, different audio goes out. You
configure a processor, provide it an input and output buffer and it fill the
output buffer with accordingly processed audio. Create a processor with
`mkProcessor`. Configure the processor with `processorSetParam`. Some processors
may create more audio than what is input into them (e.g. a reverb). For this
reason you must call `processorBufferSize` with the size of your input buffer to
make sure your output buffer is large enough to contain all the audio. This is
not necessary if you do not care for the extra audio. Call `processorProcess`
with an appropriately large buffer to modify the audio in-place. Alike sources,
processors may be reused - creating them over and over is wasteful. Once you're
done playing with your processor, call `processorDestroy` to free its memory.

A processor is equally simple in implementation as a source. It consists of the
following functions:
* `SetParam`: configure the source. Same warnings as for sources apply here.
* `BufferSize`: calculate the size of an output buffer. This function is passed
  the size of the input buffer, but not the contents of it.
* `Process`: process a buffer. This is where you apply the effect of this
  processor to audio according to the configuration. Take audio from one buffer
  and output audio in the other.
* `Destroy`: free any memory allocated for the processor. Same song and dance as
  for sources.

Example code:

```c
#include "core/source.h"
#include "core/processor.h"

/* utility function */
static Buffer applyProcessor(Buffer *buffer, Processor *processor) {
  size_t bufferLength = processorBufferSize(processor, buffer->length);
  /* in case the output may be shorter than the input */
  if(bufferLength < buffer->length) {
    buffer->length = bufferLength;
    processorProcess(processor, buffer);
    return emptyBuffer();
  }
  /* in case the length doesn't change */
  if(bufferLength == buffer->length) {
    processorProcess(processor, buffer);
    return emptyBuffer();
  }
  /* if we need a larger buffer, allocate one and copy the old buffer's data */
  Buffer newBuffer = mkBuffer(bufferLength, buffer->sampleRate);
  copyBuffer(&newBuffer, buffer);
  processorProcess(processor, buffer);
  return newBuffer;
}

int main() {
  int sampleRate = DEFAULT_SAMPLE_RATE;

  /* create and configure a sine wave source */
  Source source = mkSource("sine");
  sourceSetParam(&source, "duration", 1.5);
  sourceSetParam(&source, "freq", 500.0);
  sourceSetParam(&source, "amplitude", 0.9);

  /* generate a buffer and fill it with samples */
  size_t bufferLength = sourceBufferSize(&source, sampleRate);
  Buffer buffer = mkBuffer(sampleRate, bufferLength);
  sourceFillBuffer(&source, &buffer);
  /* no longer need it, so we destroy it */
  sourceDestroy(&source);

  /* create and configure two processors */
  Processor gain = mkProcessor("gain");
  processorSetParam(&gain, "gain", 1.3);
  Processor hardClip = mkProcessor("hardClip");
  processorSetParam(&hardClip, "threshold", 0.9);
  processorSetParam(&hardClip, "synched", 1);

  /* apply them with the utility function */
  applyProcessor(&buffer, &gain);
  applyProcessor(&buffer, &hardClip);

  /* destroy everything */
  destroyBuffer(&buffer);
  processorDestroy(&gain);
  processorDestroy(&hardClip);

  return 0;
}
```
